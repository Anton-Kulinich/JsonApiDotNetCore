<!DOCTYPE html>
<!--[if IE]><![endif]-->
<html>
  
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <title>Resource Hooks </title>
    <meta name="viewport" content="width=device-width">
    <meta name="title" content="Resource Hooks ">
    <meta name="generator" content="docfx 2.57.0.0">
    
    <link rel="shortcut icon" href="../../favicon.ico">
    <link rel="stylesheet" href="../../styles/docfx.vendor.css">
    <link rel="stylesheet" href="../../styles/docfx.css">
    <link rel="stylesheet" href="../../styles/main.css">
    <meta property="docfx:navrel" content="../../toc.html">
    <meta property="docfx:tocrel" content="../toc.html">
    
    
    
  </head>
  <body data-spy="scroll" data-target="#affix" data-offset="120">
    <div id="wrapper">
      <header>
        
        <nav id="autocollapse" class="navbar navbar-inverse ng-scope" role="navigation">
          <div class="container">
            <div class="navbar-header">
              <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#navbar">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
              </button>
              
              <a class="navbar-brand" href="../../index.html">
                <img id="logo" class="svg" src="../../logo.svg" alt="">
              </a>
            </div>
            <div class="collapse navbar-collapse" id="navbar">
              <form class="navbar-form navbar-right" role="search" id="search">
                <div class="form-group">
                  <input type="text" class="form-control" id="search-query" placeholder="Search" autocomplete="off">
                </div>
              </form>
            </div>
          </div>
        </nav>
        
        <div class="subnav navbar navbar-default">
          <div class="container hide-when-search" id="breadcrumb">
            <ul class="breadcrumb">
              <li></li>
            </ul>
          </div>
        </div>
      </header>
      <div role="main" class="container body-content hide-when-search">
        
        <div class="sidenav hide-when-search">
          <a class="btn toc-toggle collapse" data-toggle="collapse" href="#sidetoggle" aria-expanded="false" aria-controls="sidetoggle">Show / Hide Table of Contents</a>
          <div class="sidetoggle collapse" id="sidetoggle">
            <div id="sidetoc"></div>
          </div>
        </div>
        <div class="article row grid-right">
          <div class="col-md-10">
            <article class="content wrap" id="_content" data-uid="">
<h1 id="resource-hooks">Resource Hooks</h1>

<p>This section covers the usage of <strong>Resource Hooks</strong>, which is a feature of<code>ResourceHooksDefinition&lt;T&gt;</code>. See the <a href="resource-definitions.html">ResourceDefinition usage guide</a> for a general explanation on how to set up a <code>JsonApiResourceDefinition&lt;T&gt;</code>. For a quick start, jump right to the <a href="#getting-started-most-minimal-example">Getting started: most minimal example</a> section.</p>
<blockquote><p>Note: Resource Hooks are an experimental feature and are turned off by default. They are subject to change or be replaced in a future version.</p>
</blockquote>
<p>By implementing resource hooks on a <code>ResourceHooksDefintion&lt;T&gt;</code>, it is possible to intercept the execution of the <strong>Resource Service Layer</strong> (RSL) in various ways. This enables the developer to conveniently define business logic without having to override the RSL. It can be used to implement e.g.</p>
<ul>
<li>Authorization</li>
<li><a href="https://docs.microsoft.com/en-us/dotnet/standard/microservices-architecture/multi-container-microservice-net-applications/integration-event-based-microservice-communications">Event-based synchronisation between microservices</a></li>
<li>Logging</li>
<li>Transformation of the served data</li>
</ul>
<p>This usage guide covers the following sections</p>
<ol>
<li><a href="#1-semantics-pipelines-actions-and-hooks"><strong>Semantics: pipelines, actions and hooks</strong></a>
Understanding the semantics will be helpful in identifying which hooks on <code>ResourceHooksDefinition&lt;T&gt;</code> you need to implement for your use-case.</li>
<li><a href="#2-basic-usage"><strong>Basic usage</strong></a>
    Some examples to get you started.<ul>
<li><a href="#getting-started-most-minimal-example"><strong>Getting started: most minimal example</strong></a></li>
<li><a href="#logging"><strong>Logging</strong></a></li>
<li><a href="#transforming-data-with-onreturn"><strong>Transforming data with OnReturn</strong></a></li>
<li><a href="#loading-database-values"><strong>Loading database values</strong></a></li>
</ul>
</li>
<li><a href="#3-advanced-usage"><strong>Advanced usage</strong></a>
Complicated examples that show the advanced features of hooks.<ul>
<li><a href="#simple-authorization-explicitly-affected-resources"><strong>Simple authorization: explicitly affected resources</strong></a></li>
<li><a href="#advanced-authorization-implicitly-affected-resources"><strong>Advanced authorization: implicitly affected resources</strong></a></li>
<li><a href="#synchronizing-data-across-microservices"><strong>Synchronizing data across microservices</strong></a></li>
<li><a href="#hooks-for-many-to-many-join-tables"><strong>Hooks for many-to-many join tables</strong></a></li>
</ul>
</li>
<li><a href="#4-hook-execution-overview"><strong>Hook execution overview</strong></a>
A table overview of all pipelines and involved hooks</li>
</ol>
<h1 id="1-semantics-pipelines-actions-and-hooks">1. Semantics: pipelines, actions and hooks</h1>
<h2 id="pipelines">Pipelines</h2>
<p>The different execution flows within the RSL that may be intercepted can be identified as <strong>pipelines</strong>. Examples of such pipelines are</p>
<ul>
<li><strong>Post</strong>: creation of a resource (triggered by the endpoint <code>POST /my-resource</code>).</li>
<li><strong>PostBulk</strong>: creation of multiple resources (triggered by the endpoint <code>POST /bulk/my-resource</code>).<ul>
<li><em>NB: hooks are not yet supported with bulk operations.</em></li>
</ul>
</li>
<li><strong>Get</strong>: reading a resource (triggered by the endpoint <code>GET /my-resource</code>).</li>
<li><strong>GetSingle</strong>: reading a single resource (triggered by the endpoint <code>GET /my-resource/1</code>).</li>
</ul>
<p>See the <a href="https://github.com/json-api-dotnet/JsonApiDotNetCore/blob/745d2fb6b6c9dd21ff794284a193977fdc699fe6/src/JsonApiDotNetCore/Hooks/Internal/Execution/ResourcePipeline.cs">ResourcePipeline</a> enum for a full list of available pipelines.</p>
<h2 id="actions">Actions</h2>
<p>Each pipeline is associated with a set of <strong>actions</strong> that work on resources and their relationships. These actions reflect the associated database operations that are performed by JsonApiDotNetCore (in the Repository Layer). Typically, the RSL will execute some service-layer-related code, then invoke the Repository Layer which will perform these actions, after which the execution returns to the RSL.</p>
<p>Note that some actions are shared across different pipelines, and note that most pipelines perform multiple actions.  There are two types of actions: <strong>primary resource actions</strong> and <strong>nested resource actions</strong>.</p>
<h3 id="primary-resource-actions">Primary resource actions</h3>
<p>Most actions are trivial in the context of the pipeline where they&#39;re executed from. They may be recognised as the familiar <em>CRUD</em> operations of an API. These actions are:</p>
<ul>
<li>The <code>create</code> action: the <strong>Post</strong> pipeline will <code>create</code> a resource</li>
<li>The <code>read</code> action: the <strong>Get</strong> and  <strong>GetSingle</strong> pipeline will <code>read</code> (a) resource(s).</li>
<li>The <code>update</code> action: the <strong>Patch</strong> pipeline will <code>update</code> a resource.</li>
<li>The <code>delete</code> action: the <strong>Delete</strong> pipeline will <code>delete</code> a resource.</li>
</ul>
<p>These actions are called the <strong>primary resource actions</strong> of a particular pipeline because <strong>they act on the request resource</strong>. For example, when an <code>Article</code> is created through the <strong>Post</strong> pipeline, its main action, <code>create</code>, will work on that <code>Article</code>.</p>
<h3 id="nested-resource-actions">Nested Resource Actions</h3>
<p>Some other actions might be overlooked, namely the nested resource actions. These actions are</p>
<ul>
<li><code>update relationship</code>  for directly affected relationships</li>
<li><code>implicit update relationship</code> for implicitly affected relationships</li>
<li><code>read</code> for included relationships</li>
</ul>
<p>These actions are called <strong>nested resource actions</strong> of a particular pipeline because <strong>they act on involved (nested) resources</strong> instead of the primary request resource. For example, when loading articles and their respective authors (<code>GET /articles?include=author</code>), the <code>read</code> action on <code>Article</code> is the primary action, and the <code>read</code> action on <code>Person</code> is the nested action.</p>
<h4 id="the-update-relationship-action">The <code>update relationship</code> action</h4>
<p><a href="https://jsonapi.org/format/#crud-creating">As per the Json:Api specification](https://jsonapi.org/format/#crud-creating</a>, the <strong>Post</strong> pipeline also allows for an <code>update relationship</code> action on an already existing resource. For example, when creating an <code>Article</code> it is possible to simultaneously relate it to an existing <code>Person</code> by setting its author. In this case, the <code>update relationship</code> action is a nested action that will work on that <code>Person</code>.</p>
<h4 id="the-implicit-update-relationship-action">The <code>implicit update relationship</code> action</h4>
<p>the <strong>Delete</strong>  pipeline also allows for an <code>implicit update relationship</code> action on an already existing resource. For example, for an  <code>Article</code> that its author property assigned to a particular <code>Person</code>,  the relationship between them is destroyed when this article is deleted. This update is &quot;implicit&quot; in the sense that no explicit information about that <code>Person</code> was provided in the request that triggered this pipeline. An <code>implicit update relationship</code> action is therefore performed on that <code>Person</code>.  See <a href="#advanced-authorization-implicitly-affected-resources">this section</a> for a more detailed explanation.</p>
<h3 id="shared-actions">Shared actions</h3>
<p>Note that <strong>some actions are shared across pipelines</strong>. For example, both the <strong>Post</strong> and <strong>Patch</strong> pipeline can perform the <code>update relationship</code>  action on an (already existing) involved resource. Similarly, the <strong>Get</strong> and <strong>GetSingle</strong> pipelines perform the same <code>read</code> action.
<br><br>
For a complete list of actions associated with each pipeline, see the <a href="#4-hook-execution-overview">overview table</a>.</p>
<h2 id="hooks">Hooks</h2>
<p>For all actions it is possible to implement <strong>at least one hook</strong> to intercept its execution. These hooks can be implemented by overriding the corresponding virtual  implementation on <code>ResourceHooksDefintion&lt;T&gt;</code>. (Note that the base implementation is a dummy implementation, which is ignored when firing hooks.)</p>
<h3 id="action-related-hooks">Action related hooks</h3>
<p>As an example, consider the <code>create</code> action for the <code>Article</code> Resource. This action can be intercepted by overriding the</p>
<ul>
<li><code>ResourceHooksDefinition&lt;Article&gt;.BeforeCreate</code> hook for custom logic <strong>just before</strong> execution of the main <code>create</code> action</li>
<li><code>ResourceHooksDefinition&lt;Article&gt;.AfterCreate</code> hook for custom logic <strong>just after</strong> execution of the main <code>create</code> action</li>
</ul>
<p>If with the creation of an <code>Article</code>  a relationship to <code>Person</code> is updated simultaneously, this can be intercepted by overriding the</p>
<ul>
<li><code>ResourceHooksDefinition&lt;Person&gt;.BeforeUpdateRelationship</code> hook for custom logic <strong>just before</strong> the execution of the nested <code>update relationship</code> action.</li>
<li><code>ResourceHooksDefinition&lt;Person&gt;.AfterUpdateRelationship</code> hook for custom logic <strong>just after</strong> the execution of the nested <code>update relationship</code> action.</li>
</ul>
<h3 id="onreturn-hook">OnReturn hook</h3>
<p>As mentioned in the previous section, some actions are shared across hooks. One of these actions is the <code>return</code> action. Although not strictly compatible with the <em>CRUD</em> vocabulary, and although not executed by the Repository Layer, pipelines are also said to perform a <code>return</code> action when any content is to be returned from the API. For example, the <strong>Delete</strong> pipeline does not return any content, but a <em>HTTP 204 No Content</em> instead, and will therefore not perform a <code>return</code> action. On the contrary, the <strong>Get</strong> pipeline does return content, and will therefore perform a <code>return action</code></p>
<p>Any return content can be intercepted and transformed as desired by implementing the <code>ResourceHooksDefinition&lt;TEntity&gt;.OnReturn</code> hook which intercepts the <code>return</code> action. For this action, there is no distinction between a <code>Before</code> and <code>After</code> hook, because no code after a <code>return</code> statement can be evaluated. Note that the <code>return</code> action can work on <em>primary resources as well as nested resources</em>, see  <a href="#transforming-data-with-onreturn">this example below</a>.
<br><br>
For an overview of all pipelines, hooks and actions, see the table below, and for more detailed information about the available hooks, see the <a href="https://github.com/json-api-dotnet/JsonApiDotNetCore/blob/ab1f96d8255532461da47d290c5440b9e7e6a4a5/src/JsonApiDotNetCore/Hooks/IResourceHookContainer.cs">IResourceHookContainer<t></t></a> interface.</p>
<h1 id="2-basic-usage">2. Basic usage</h1>
<h2 id="getting-started-most-minimal-example">Getting started: most minimal example</h2>
<p>To use resource hooks, you are required to turn them on in your <code>startup.cs</code> configuration</p>
<pre><code class="lang-c#">public void ConfigureServices(IServiceCollection services)
{
    // ...

    services.AddJsonApi&lt;ApiDbContext&gt;(options =&gt;
    {
        options.EnableResourceHooks = true; // default is false
        options.LoadDatabaseValues = false; // default is false
    });

    // ...
}
</code></pre><p>For this example, we may set <code>LoadDatabaseValues</code> to <code>false</code>. See the <a href="#loading-database-values">Loading database values</a> example for more information about this option.</p>
<p>The simplest case of resource hooks we can then implement should not require a lot of explanation. This hook would be triggered by any default JsonApiDotNetCore API route for <code>Article</code>.</p>
<pre><code class="lang-c#">public class ArticleResource : ResourceHooksDefinition&lt;Article&gt;
{
    public override IEnumerable&lt;Article&gt; OnReturn(HashSet&lt;Article&gt; entities,
        ResourcePipeline pipeline)
    {
        Console.WriteLine(&quot;This hook does not do much apart from writing this message&quot; +
             &quot; to the console just before serving the content.&quot;);
        return entities;
    }
}
</code></pre><h2 id="logging">Logging</h2>
<p>This example shows how some actions can be logged on the level of API users.</p>
<p>First consider the following scoped service which creates a logger bound to a particular user and request.</p>
<pre><code class="lang-c#">/// This is a scoped service, which means log will have a request-based
/// unique id associated to it.
public class UserActionsLogger : IUserActionsLogger
{
    public ILogger Instance { get; private set; }

    public UserActionsLogger(ILoggerFactory loggerFactory, IUserService userService)
    {
        var userId = userService.GetUser().Id;
        Instance =
            loggerFactory.CreateLogger($&quot;[request: {Guid.NewGuid()}&quot; + &quot;user: {userId}]&quot;);
    }
}
</code></pre><p>Now, let&#39;s assume our application has two resources: <code>Article</code> and <code>Person</code>, and that there exist a one-to-one  and one-to-many relationship between them (<code>Article</code> has one <code>Author</code> and <code>Article</code> has many <code>Reviewers</code>). Let&#39;s assume we are required to log the following events:</p>
<ul>
<li>An API user deletes an article</li>
<li>An API user removes the <code>Author</code> relationship of a person</li>
<li>An API user removes the <code>Reviewer</code> relationship of a person</li>
</ul>
<p>This could be achieved in the following way:</p>
<pre><code class="lang-c#">/// Note that resource definitions are also registered as scoped services.
public class ArticleResource : ResourceHooksDefinition&lt;Article&gt;
{
    private readonly ILogger _userLogger;

    public ArticleResource(IUserActionsLogger logService)
    {
        _userLogger = logService.Instance;
    }

    public override void AfterDelete(HashSet&lt;Article&gt; entities, ResourcePipeline pipeline,
        bool succeeded)
    {
        if (!succeeded)
        {
            return;
        }

        foreach (Article article in entities)
        {
            _userLogger.Log(LogLevel.Information,
                $&quot;Deleted article &#39;{article.Name}&#39; with id {article.Id}&quot;);
        }
    }
}

public class PersonResource : ResourceHooksDefinition&lt;Person&gt;
{
    private readonly ILogger _userLogger;

    public PersonResource(IUserActionsLogger logService)
    {
        _userLogger = logService.Instance;
    }

    public override void AfterUpdateRelationship(
        IAffectedRelationships&lt;Person&gt; resourcesByRelationship, ResourcePipeline pipeline)
    {
        var updatedRelationshipsToArticle = relationshipHelper.EntitiesRelatedTo&lt;Article&gt;();

        foreach (var updated in updatedRelationshipsToArticle)
        {
            RelationshipAttribute relationship = updated.Key;
            HashSet&lt;Person&gt; affectedEntities = updated.Value;

            foreach (Person person in affectedEntities)
            {
                if (pipeline == ResourcePipeline.Delete)
                {
                    _userLogger.Log(LogLevel.Information,
                        $&quot;Deleted the {relationship.PublicRelationshipName} relationship &quot; +
                        $&quot;to Article for person &#39;{person.FirstName} {person.LastName}&#39; &quot; +
                        $&quot;with id {person.Id}&quot;);
                }
            }
        }
    }
}
</code></pre><p>If eg. an API user deletes an article with title <em>JSON:API paints my bikeshed!</em> that had related as author <em>John Doe</em> and as reviewer <em>Frank Miller</em>, the logs generated logs would look something like</p>
<pre><code>[request: 186190e3-1900-4329-9181-42082258e7b4, user: dd1cd99d-60e9-45ca-8d03-a0330b07bdec] Deleted article &#39;JSON:API paints my bikeshed!&#39; with id fac0436b-7aa5-488e-9de7-dbe00ff8f04d
[request: 186190e3-1900-4329-9181-42082258e7b4, user: dd1cd99d-60e9-45ca-8d03-a0330b07bdec] Deleted the author relationship to Article for person &#39;John Doe&#39; with id 2ec3990d-c816-4d6d-8531-7da4a030d4d0
[request: 186190e3-1900-4329-9181-42082258e7b4, user: dd1cd99d-60e9-45ca-8d03-a0330b07bdec] Deleted the reviewer relationship to Article for person &#39;Frank Miller&#39; with id 42ad6eb2-b813-4261-8fc1-0db1233e665f
</code></pre><h2 id="transforming-data-with-onreturn">Transforming data with OnReturn</h2>
<p>Using the <code>OnReturn</code> hook, any set of resources can be manipulated as desired before serving it from the API. One of the use-cases for this is being able to perform a <a href="https://github.com/aspnet/EntityFrameworkCore/issues/1833">filtered include</a>, which is currently not supported by Entity Framework Core.</p>
<p>As an example, consider again an application with the <code>Article</code>  and <code>Person</code> resource, and let&#39;s assume the following business rules:</p>
<ul>
<li>when reading <code>Article</code>s, we never want to show articles for which the <code>IsSoftDeleted</code> property is set to true.</li>
<li>when reading <code>Person</code>s, we never want to show people who wish to remain anonymous (<code>IsAnonymous</code> is set to true).</li>
</ul>
<p>This can be achieved as follows:</p>
<pre><code class="lang-c#">public class ArticleResource : ResourceHooksDefinition&lt;Article&gt;
{
    public override IEnumerable&lt;Article&gt; OnReturn(HashSet&lt;Article&gt; entities,
        ResourcePipeline pipeline)
    {
        return entities.Where(article =&gt; !article.IsSoftDeleted);
    }
}

public class PersonResource : ResourceHooksDefinition&lt;Person&gt;
{
    public override IEnumerable&lt;Person&gt; OnReturn(HashSet&lt;Person&gt; entities,
        ResourcePipeline pipeline)
    {
        if (pipeline == ResourcePipeline.Get)
        {
            return entities.Where(person =&gt; !person.IsAnonymous);
        }
        return entities;
    }
}
</code></pre><p>Note that not only anonymous people will be excluded when directly performing a <code>GET /people</code>, but also when included through relationships, like <code>GET /articles?include=author,reviewers</code>. Simultaneously, <code>if</code> condition that checks for <code>ResourcePipeline.Get</code> in the <code>PersonResource</code> ensures we still get expected responses from the API when eg. creating a person with <code>WantsPrivacy</code> set to true.</p>
<h2 id="loading-database-values">Loading database values</h2>
<p>When a hook is executed for a particular resource, JsonApiDotNetCore can load the corresponding database values and provide them in the hooks. This can be useful for eg.</p>
<ul>
<li>having a diff between a previous and new state of a resource (for example when updating a resource)</li>
<li>performing authorization rules based on the property of a resource.</li>
</ul>
<p>For example, consider a scenario with the following two requirements:</p>
<ul>
<li>We need to log all updates on resources revealing their old and new value.</li>
<li>We need to check if the property <code>IsLocked</code> is set is <code>true</code>, and if so, cancel the operation.</li>
</ul>
<p>Consider an <code>Article</code> with title <em>Hello there</em> and API user trying to update the the title of this article to <em>Bye bye</em>.  The above requirements could be implemented as follows:</p>
<pre><code class="lang-c#">public class ArticleResource : ResourceHooksDefinition&lt;Article&gt;
{
    private readonly ILogger _logger;
    private readonly ITargetedFields _targetedFields;

    public constructor ArticleResource(ILogger logger, ITargetedFields targetedFields)
    {
        _logger = logger;
        _targetedFields = targetedFields;
    }

    public override IEnumerable&lt;Article&gt; BeforeUpdate(IResourceDiff&lt;Article&gt; entityDiff,
        ResourcePipeline pipeline)
    {
        // PropertyGetter is a helper class that takes care of accessing the values
        // on an instance of Article using reflection.
        var getter = new PropertyGetter&lt;Article&gt;();

        // ResourceDiff&lt;T&gt; is like a list that contains ResourceDiffPair&lt;T&gt; elements
        foreach (ResourceDiffPair&lt;Article&gt; affected in entityDiff)
        {
            // the current state in the database
            var currentDatabaseState = affected.DatabaseValue;

            // the value from the request
            var proposedValueFromRequest = affected.Entity;

            if (currentDatabaseState.IsLocked)
            {
                throw new JsonApiException(403, &quot;Forbidden: this article is locked!&quot;)
            }

            foreach (var attr in _targetedFields.Attributes)
            {
                var oldValue = getter(currentDatabaseState, attr);
                var newValue = getter(proposedValueFromRequest, attr);

                _logger.LogAttributeUpdate(oldValue, newValue)
            }
        }

        // You must return IEnumerable&lt;Article&gt; from this hook.
        // This means that you could reduce the set of entities that is
        // affected by this request, eg. by entityDiff.Entities.Where( ... );
        entityDiff.Entities;
    }
}
</code></pre><p>In this case the <code>ResourceDiffPair&lt;T&gt;.DatabaseValue</code> is <code>null</code>.  If you try to access all database values at once (<code>ResourceDiff.DatabaseValues</code>) when it is turned off, an exception will be thrown.</p>
<p>Note that database values are turned off by default. They can be turned on globally by configuring the startup as follows:</p>
<pre><code class="lang-c#">public void ConfigureServices(IServiceCollection services)
{
    // ...

    services.AddJsonApi&lt;ApiDbContext&gt;(options =&gt;
    {
        options.LoadDatabaseValues = true;
    });

    // ...
}
</code></pre><p>The global setting can be used together with per-hook configuration hooks using the <code>LoadDatabaseValues</code> attribute:</p>
<pre><code class="lang-c#">public class ArticleResource : ResourceHooksDefinition&lt;Article&gt;
{
    [LoadDatabaseValues(true)]
    public override IEnumerable&lt;Article&gt; BeforeUpdate(IResourceDiff&lt;Article&gt; entityDiff,
        ResourcePipeline pipeline)
    {
        // ...
    }

    [LoadDatabaseValues(false)]
    public override IEnumerable&lt;string&gt; BeforeUpdateRelationships(HashSet&lt;string&gt; ids,
        IAffectedRelationships&lt;Article&gt; resourcesByRelationship, ResourcePipeline pipeline)
    {
        // the entities stored in the IAffectedRelationships&lt;Article&gt; instance
        // are plain resource identifier objects when LoadDatabaseValues is turned off,
        // or objects loaded from the database when LoadDatabaseValues is turned on.
     }
  }
}
</code></pre><p>Note that there are some hooks that the <code>LoadDatabaseValues</code> option and attribute does not affect. The only hooks that are affected are:</p>
<ul>
<li><code>BeforeUpdate</code></li>
<li><code>BeforeUpdateRelationship</code></li>
<li><code>BeforeDelete</code></li>
</ul>
<h1 id="3-advanced-usage">3. Advanced usage</h1>
<h2 id="simple-authorization-explicitly-affected-resources">Simple authorization: explicitly affected resources</h2>
<p>Resource hooks can be used to easily implement authorization in your application.  As an example, consider the case in which an API user is not allowed to see anonymous people, which is reflected by the <code>Anonymous</code> property on <code>Person</code> being set to <code>true</code>. The API should handle this as follows:</p>
<ul>
<li>When reading people (<code>GET /people</code>), it should hide all people that are set to anonymous.</li>
<li>When reading a single person (<code>GET /people/{id}</code>), it should throw an authorization error if the particular requested person is set to anonymous.</li>
</ul>
<p>This can be achieved as follows:</p>
<pre><code class="lang-c#">public class PersonResource : ResourceHooksDefinition&lt;Person&gt;
{
    private readonly _IAuthorizationHelper _auth;

    public constructor PersonResource(IAuthorizationHelper auth)
    {
      // IAuthorizationHelper is a helper service that handles all authorization related logic.
      _auth = auth;
    }

    public override IEnumerable&lt;Person&gt; OnReturn(HashSet&lt;Person&gt; entities,
        ResourcePipeline pipeline)
    {
        if (!_auth.CanSeeSecretPeople())
        {
            if (pipeline == ResourcePipeline.GetSingle)
            {
                throw new JsonApiException(403, &quot;Forbidden to view this person&quot;,
                    new UnauthorizedAccessException());
            }

            entities = entities.Where(person =&gt; !person.IsSecret)
        }

        return entities;
    }
}
</code></pre><p>This example of authorization is considered simple because it only involves one resource. The next example shows a more complex case.</p>
<h2 id="advanced-authorization-implicitly-affected-resources">Advanced authorization: implicitly affected resources</h2>
<p>Let&#39;s consider an authorization scenario for which we are required to implement multiple hooks across multiple resource definitions. We will assume the following:</p>
<ul>
<li>There exists a one-to-one relationship between <code>Article</code> and <code>Person</code>: an article can have only one author, and a person can be author of only one article.</li>
<li>The author of article <code>Old Article</code> is person <code>Alice</code>.</li>
<li>The author of article <code>New Article</code> is person <code>Bob</code>.</li>
</ul>
<p>Now let&#39;s consider an API user that tries to update <code>New Article</code> by setting its author to <code>Alice</code>. The request would look something like <code>PATCH /articles/{ArticleId}</code> with a body containing a reference to <code>Alice</code>.</p>
<p>First to all, we wish to authorize this operation by the verifying permissions related to the resources that are <strong>explicity affected</strong>  by it:</p>
<ol>
<li>Is the API user allowed to update <code>Article</code>?</li>
<li>Is the API user allowed to update <code>Alice</code>?</li>
</ol>
<p>Apart from this, we also wish to verify permissions for the resources that are <strong>implicitly affected</strong> by this operation: <code>Bob</code> and <code>Old Article</code>. Setting <code>Alice</code> as the new author of <code>Article</code> will result in removing the following two relationships:  <code>Bob</code> being an author of <code>Article</code>, and <code>Alice</code> being an author of  <code>Old Article</code>. Therefore, we wish wish to verify the related permissions:</p>
<ol>
<li>Is the API user allowed to update <code>Bob</code>?</li>
<li>Is the API user allowed to update <code>Old Article</code>?</li>
</ol>
<p>This authorization requirement can be fulfilled as follows.</p>
<p>For checking the permissions for the explicitly affected resources, <code>Article</code> and <code>Alice</code>, we may implement the <code>BeforeUpdate</code> hook for <code>Article</code>:</p>
<pre><code class="lang-c#">public override IEnumerable&lt;Article&gt; BeforeUpdate(IResourceDiff&lt;Article&gt; entityDiff,
    ResourcePipeline pipeline)
{
    if (pipeline == ResourcePipeline.Patch)
    {
        Article article = entityDiff.RequestEntities.Single();

        if (!_auth.CanEditResource(article))
        {
            throw new JsonApiException(403, &quot;Forbidden to update properties of this article&quot;,
                new UnauthorizedAccessException());
        }

        if (entityDiff.GetByRelationship&lt;Person&gt;().Any() &amp;&amp;
            _auth.CanEditRelationship&lt;Person&gt;(article))
        {
            throw new JsonApiException(403, &quot;Forbidden to update relationship of this article&quot;,
                new UnauthorizedAccessException());
        }
    }

    return entityDiff.RequestEntities;
}
</code></pre><p>and the <code>BeforeUpdateRelationship</code> hook for <code>Person</code>:</p>
<pre><code class="lang-c#">public override IEnumerable&lt;string&gt; BeforeUpdateRelationship(HashSet&lt;string&gt; ids,
    IAffectedRelationships&lt;Person&gt; resourcesByRelationship, ResourcePipeline pipeline)
{
    var updatedOwnerships = resourcesByRelationship.GetByRelationship&lt;Article&gt;();

    if (updatedOwnerships.Any())
    {
        Person person =
            resourcesByRelationship.GetByRelationship&lt;Article&gt;().Single().Value.First();

        if (_auth.CanEditRelationship&lt;Article&gt;(person))
        {
            throw new JsonApiException(403, &quot;Forbidden to update relationship of this person&quot;,
                new UnauthorizedAccessException());
        }
    }

    return ids;
}
</code></pre><p>To verify the permissions for the implicitly affected resources, <code>Old Article</code> and <code>Bob</code>, we need to implement the <code>BeforeImplicitUpdateRelationship</code> hook for <code>Article</code>:</p>
<pre><code class="lang-c#">public override void BeforeImplicitUpdateRelationship(
    IAffectedRelationships&lt;Article&gt; resourcesByRelationship, ResourcePipeline pipeline)
{
    var updatedOwnerships = resourcesByRelationship.GetByRelationship&lt;Person&gt;();

    if (updatedOwnerships.Any())
    {
        Article article =
            resourcesByRelationship.GetByRelationship&lt;Person&gt;().Single().Value.First();

        if (_auth.CanEditRelationship&lt;Person&gt;(article))
        {
            throw new JsonApiException(403, &quot;Forbidden to update relationship of this article&quot;,
                new UnauthorizedAccessException());
        }
    }
}
</code></pre><p>and similarly for <code>Person</code>:</p>
<pre><code class="lang-c#">public override void BeforeImplicitUpdateRelationship(
    IAffectedRelationships&lt;Person&gt; resourcesByRelationship, ResourcePipeline pipeline)
{
    var updatedOwnerships = resourcesByRelationship.GetByRelationship&lt;Article&gt;();
    if (updatedOwnerships.Any())
    {
        Person person =
            resourcesByRelationship.GetByRelationship&lt;Article&gt;().Single().Value.First();

        if (_auth.CanEditRelationship&lt;Article&gt;(person))
        {
            throw new JsonApiException(403, &quot;Forbidden to update relationship of this article&quot;,
                new UnauthorizedAccessException());
        }
    }
}
</code></pre><h2 id="using-resource-hooks-without-entity-framework-core">Using Resource Hooks without Entity Framework Core</h2>
<p>If you want to use Resource Hooks without Entity Framework Core, there are several things that you need to consider that need to be met. For any resource that you want to use hooks for:</p>
<ol>
<li>The corresponding resource repository must fully implement <code>IResourceReadRepository&lt;TEntity, TId&gt;</code></li>
<li>If you are using custom services, you will be responsible for injecting the <code>IResourceHookExecutor</code> service into your services and call the appropriate methods. See the <a href="#4-hook-execution-overview">hook execution overview</a> to determine which hook should be fired in which scenario.</li>
</ol>
<p>If you are required to use the <code>BeforeImplicitUpdateRelationship</code> hook (see previous example), there is an additional requirement. For this hook, given a particular relationship, JsonApiDotNetCore needs to be able to resolve the inverse relationship. For example: if <code>Article</code> has one  author (a <code>Person</code>), then it needs to be able to resolve the <code>RelationshipAttribute</code> that corresponds to the inverse relationship for the <code>author</code> property. There are two approaches :</p>
<ol>
<li><strong>Tell JsonApiDotNetCore how to do this only for the relevant models</strong>.  If you&#39;re using the <code>BeforeImplicitUpdateRelationship</code> hook only for a small set of models, eg only for the relationship of the example, then it is easiest to provide the <code>inverseNavigationProperty</code> as follows:</li>
</ol>
<pre><code class="lang-c#">public class Article : Identifiable
{
    [HasOne(&quot;author&quot;, InverseNavigationProperty: &quot;OwnerOfArticle&quot;)]
    public Person Author { get; set; }
}

public class Person : Identifiable
{
    [HasOne(&quot;article&quot;)]
    public Article OwnerOfArticle { get; set; }
}
</code></pre><ol>
<li><strong>Tell JsonApiDotNetCore how to do this in general</strong>. For full support, you can provide JsonApiDotNetCore with a custom service implementation of the <code>IInverseNavigationResolver</code> interface. relationship of the example, then it is easiest to provide the <code>InverseNavigationProperty</code> as follows:</li>
</ol>
<pre><code class="lang-c#">public class CustomInverseNavigationResolver : IInverseNavigationResolver
{
    public void Resolve()
    {
        // the implementation of this method depends completely on
        // the data access layer you&#39;re using.
        // It should set the RelationshipAttribute.InverseNavigationProperty property
        // for all (relevant) relationships.
        // To have an idea of how to implement this method, see the InverseNavigationResolver class
        // in the source code of JsonApiDotNetCore.
    }
}
</code></pre><p>This service will then be run once at startup and take care of the metadata that is required for <code>BeforeImplicitUpdateRelationship</code> to be supported.</p>
<p><em>Note: don&#39;t forget to register this singleton service with the service provider.</em></p>
<h2 id="synchronizing-data-across-microservices">Synchronizing data across microservices</h2>
<p>If your application is built using a microservices infrastructure, it may be relevant to propagate data changes between microservices, <a href="https://docs.microsoft.com/en-us/dotnet/standard/microservices-architecture/multi-container-microservice-net-applications/integration-event-based-microservice-communications">see this article for more information</a>. In this example, we will assume the implementation of an event bus and we will publish data consistency integration events using resource hooks.</p>
<pre><code class="lang-c#">public class ArticleResource : ResourceHooksDefinition&lt;Article&gt;
{
    private readonly IEventBus _bus;
    private readonly IJsonApiContext _context;

    public ArticleResource(IEventBus bus, IJsonApiContext context)
    {
        _bus = bus;
        _context = context;
    }

    public override void AfterCreate(HashSet&lt;Article&gt; entities, ResourcePipeline pipeline)
    {
        foreach (var article in entities )
        {
            var @event = new ResourceCreatedEvent(article);
            _bus.Publish(@event);
        }
    }

    public override void AfterDelete(HashSet&lt;Article&gt; entities, ResourcePipeline pipeline,
        bool succeeded)
    {
        foreach (var article in entities)
        {
            var @event = new ResourceDeletedEvent(article);
            _bus.Publish(@event);
        }
    }

    public override void AfterUpdate(HashSet&lt;Article&gt; entities, ResourcePipeline pipeline)
    {
        foreach (var article in entities)
        {
            // You could inject ITargetedFields and use it to pass along
            // only the attributes that were updated

            var @event = new ResourceUpdatedEvent(article,
                properties: _targetedFields.Attributes);

            _bus.Publish(@event);
        }
    }
}
</code></pre><h2 id="hooks-for-many-to-many-join-tables">Hooks for many-to-many join tables</h2>
<p>In this example we consider an application with a many-to-many relationship: <code>Article</code> and <code>Tag</code>, with an internally used <code>ArticleTag</code> join-type.</p>
<p>Usually, join table records will not contain any extra information other than that which is used internally for the many-to-many relationship. For this example, the join-type should then look like:</p>
<pre><code class="lang-c#">public class ArticleTag
{
    public int ArticleId { get; set; }
    public Article Article { get; set; }

    public int TagId { get; set; }
    public Tag Tag { get; set; }
}
</code></pre><p>If we then eg. implement the <code>AfterRead</code> and <code>OnReturn</code> hook for <code>Article</code> and <code>Tag</code>, and perform a <code>GET /articles?include=tags</code> request, we may expect the following order of execution:</p>
<ol>
<li>Article AfterRead</li>
<li>Tag AfterRead</li>
<li>Article OnReturn</li>
<li>Tag OnReturn</li>
</ol>
<p>Note that under the hood, the <em>join table records</em> (instances of <code>ArticleTag</code>) are also being read, but we did not implement any hooks for them. In this example, for these records, there is little relevant business logic that can be thought of.</p>
<p>Sometimes, however, relevant data may be stored in the join table of a many-to-many relationship. Let&#39;s imagine we wish to add a property <code>LinkDate</code> to the join table that reflects when a tag was added to an article. In this case, we may want to execute business logic related to these records: we may for example want to hide any tags that were added to an article longer than 2 weeks ago.</p>
<p>In order to achieve this, we need to change <code>ArticleTag</code> to <code>ArticleTagWithLinkDate</code> as follows:</p>
<pre><code class="lang-c#">public class ArticleTagWithLinkDate : Identifiable
{
    public int ArticleId { get; set; }

    [HasOne(&quot;Article&quot;)]
    public Article Article { get; set; }

    public int TagId { get; set; }

    [HasOne(&quot;Tag&quot;)]
    public Tag Tag { get; set; }

    public DateTime LinkDate { get; set; }
}
</code></pre><p>Then, we may implement a hook for <code>ArticleTagWithLinkDate</code> as usual:</p>
<pre><code class="lang-c#">public class ArticleTagWithLinkDateResource : ResourceHooksDefinition&lt;ArticleTagWithLinkDate&gt;
{
    public override IEnumerable&lt;ArticleTagWithLinkDate&gt; OnReturn(
        HashSet&lt;ArticleTagWithLinkDate&gt; entities, ResourcePipeline pipeline)
    {
        return entities.Where(article =&gt; (DateTime.Now - article.LinkDate) &lt; 14);
    }
}
</code></pre><p>Then, for the same request <code>GET /articles?include=tags</code>, the order of execution of the hooks will look like:</p>
<ol>
<li>Article AfterRead</li>
<li>Tag AfterRead</li>
<li>Article OnReturn</li>
<li>ArticleTagWithLinkDate OnReturn</li>
<li>Tag OnReturn</li>
</ol>
<p>And the included collection of tags per article will only contain tags that were added less than two weeks ago.</p>
<p>Note that the introduced inheritance and added relationship attributes does not further affect the many-to-many relationship internally.</p>
<h1 id="4-hook-execution-overview">4. Hook execution overview</h1>
<p>This table below shows the involved hooks per pipeline.
<table>
  <tr>
    <th rowspan="2">Pipeline</th>
    <th colspan="5"><span style="font-style:italic">Execution Flow</span></th>
  </tr>
  <tr>
    <td align="center"><b>Before Hooks</b></td>
    <td align="center" colspan="2"><b>Repository Actions</b></td>
    <td align="center"><b>After Hooks</b></td>
    <td align="center"><b>OnReturn</b></td>
  </tr>
  <tr>
    <td>Get</td>
    <td align="center">BeforeRead</td>
    <td align="center" colspan="2" rowspan="3">read</td>
    <td align="center">AfterRead</td>
    <td align="center">[x]</td>
  </tr>
  <tr>
    <td>GetSingle</td>
    <td align="center">BeforeRead</td>
    <td align="center">AfterRead</td>
    <td align="center">[x]</td>
  </tr>
  <tr>
    <td>GetRelationship</td>
    <td align="center">BeforeRead</td>
    <td align="center">AfterRead</td>
    <td align="center">[x]</td>
  </tr>
  <tr>
    <td>Post</td>
    <td align="center">BeforeCreate</td>
    <td align="center" colspan="2">create<br>update relationship</td>
    <td align="center">AfterCreate</td>
    <td align="center">[x]</td>
  </tr>
  <tr>
    <td>Patch</td>
    <td align="center">BeforeUpdate<br>BeforeUpdateRelationship<br>BeforeImplicitUpdateRelationship</td>
    <td align="center" colspan="2">update<br>update relationship<br>implicit update relationship</td>
    <td align="center">AfterUpdate<br>AfterUpdateRelationship</td>
    <td align="center">[x]</td>
  </tr>
  <tr>
    <td>PatchRelationship</td>
    <td align="center">BeforeUpdate<br>BeforeUpdateRelationship</td>
    <td align="center" colspan="2">update<br>update relationship<br>implicit update relationship</td>
    <td align="center">AfterUpdate<br>AfterUpdateRelationship</td>
    <td align="center">[ ]</td>
  </tr>
  <tr>
    <td>Delete</td>
    <td align="center">BeforeDelete</td>
    <td align="center" colspan="2">delete<br>implicit update relationship</td>
    <td align="center">AfterDelete</td>
    <td align="center">[ ]</td>
  </tr>
  <tr>
    <td>BulkPost</td>
    <td colspan="5" align="center"><i>Not yet supported</i></td>
  </tr>
  <tr>
    <td>BulkPatch</td>
    <td colspan="5" align="center"><i>Not yet supported</i></td>
  </tr>
  <tr>
    <td>BulkDelete</td>
    <td colspan="5" align="center"><i>Not yet supported</i></td>
  </tr>
</table></p>
</article>
          </div>
          
          <div class="hidden-sm col-md-2" role="complementary">
            <div class="sideaffix">
              <div class="contribution">
                <ul class="nav">
                  <li>
                    <a href="https://github.com/json-api-dotnet/JsonApiDotNetCore/blob/master/docs/usage/resources/hooks.md/#L1" class="contribution-link">Improve this Doc</a>
                  </li>
                </ul>
              </div>
              <nav class="bs-docs-sidebar hidden-print hidden-xs hidden-sm affix" id="affix">
                <h5>In This Article</h5>
                <div></div>
              </nav>
            </div>
          </div>
        </div>
      </div>
      
      <footer>
        <div class="grad-bottom"></div>
        <div class="footer">
          <div class="container">
            <span class="pull-right">
              <a href="#top">Back to top</a>
            </span>
            
            <span>Generated by <strong>DocFX</strong></span>
          </div>
        </div>
      </footer>
    </div>
    
    <script type="text/javascript" src="../../styles/docfx.vendor.js"></script>
    <script type="text/javascript" src="../../styles/docfx.js"></script>
    <script type="text/javascript" src="../../styles/main.js"></script>
  </body>
</html>
